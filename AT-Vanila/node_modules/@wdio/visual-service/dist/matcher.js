import { getBrowserObject } from './utils.js';
const DEFAULT_EXPECTED_RESULT = 0;
const asymmetricMatcher = typeof Symbol === 'function' && Symbol.for
    ? Symbol.for('jest.asymmetricMatcher')
    : 0x13_57_a5;
function isAsymmetricMatcher(expected) {
    return Boolean(expected && typeof expected === 'object' && '$$typeof' in expected && expected.$$typeof === asymmetricMatcher && 'asymmetricMatch' in expected);
}
function compareResult(result, expected) {
    /**
     * expected value is an asymmetric matcher, e.g.
     *
     * ```ts
     * expect(browser).toMatchScreenSnapshot('foo', expect.closeTo(0, 2))
     * ```
     */
    if (isAsymmetricMatcher(expected)) {
        const pass = expected.asymmetricMatch(result.misMatchPercentage);
        return {
            pass,
            message: () => 'Expected image to match with given asymmetric matcher but did not pass!\n'
        };
    }
    /**
     * expected value is a number
     *
     * ```ts
     * expect(browser).toMatchScreenSnapshot('foo', 0)
     * ```
     */
    if (typeof expected === 'number') {
        return {
            pass: result.misMatchPercentage === expected,
            message: () => (`Expected image to have a mismatch percentage of ${expected}%, but was ${result.misMatchPercentage}%\n` +
                'Please compare the images manually and update the baseline if the new screenshot is correct.\n' +
                `\nBaseline: ${result.folders.baseline}\n` +
                `Actual Screenshot: ${result.folders.actual}\n` +
                `Difference: ${result.folders.diff}\n` +
                '\nSee https://webdriver.io/docs/api/visual-regression.html for more information.')
        };
    }
    throw new Error(`Invalid matcher, expect either a number or an asymmetric matcher, but found ${expected}`);
}
function parseMatcherParams(tag, expectedResult, options) {
    /**
     * throw if `tag` is not a string
     */
    if (typeof tag !== 'string') {
        throw new Error(`Expected a snapshot tag as a string but received "${typeof tag}"`);
    }
    /**
     * if `expectedResult` is an object, it is an options object
     * ```ts
     * expect(browser).toMatchScreenSnapshot('foo', { hideAfterFirstScroll: [element] })
     * ```
     */
    if (typeof expectedResult === 'object' && !isAsymmetricMatcher(expectedResult)) {
        options = expectedResult;
        expectedResult = DEFAULT_EXPECTED_RESULT;
    }
    /**
     * make sure `options` is an object
     */
    if (typeof options !== 'object') {
        options = {};
    }
    /**
     * overwrite `returnAllCompareData` to allow us to provide a better assertion message
     */
    options.returnAllCompareData = true;
    return { expectedResult, options };
}
export async function toMatchScreenSnapshot(browser, tag, expectedResultOrOptions, optionsOrUndefined) {
    const { expectedResult, options } = parseMatcherParams(tag, expectedResultOrOptions, optionsOrUndefined);
    const result = await browser.checkScreen(tag, options);
    return compareResult(result, expectedResult || DEFAULT_EXPECTED_RESULT);
}
export async function toMatchFullPageSnapshot(browser, tag, expectedResultOrOptions, optionsOrUndefined) {
    const { expectedResult, options } = parseMatcherParams(tag, expectedResultOrOptions, optionsOrUndefined);
    const result = await browser.checkFullPageScreen(tag, options);
    return compareResult(result, expectedResult || DEFAULT_EXPECTED_RESULT);
}
export async function toMatchElementSnapshot(element, tag, expectedResultOrOptions, optionsOrUndefined) {
    const { expectedResult, options } = parseMatcherParams(tag, expectedResultOrOptions, optionsOrUndefined);
    const browser = getBrowserObject(await element);
    const result = await browser.checkElement(await element, tag, options);
    return compareResult(result, expectedResult || DEFAULT_EXPECTED_RESULT);
}
export async function toMatchTabbablePageSnapshot(browser, tag, expectedResultOrOptions, optionsOrUndefined) {
    const { expectedResult, options } = parseMatcherParams(tag, expectedResultOrOptions, optionsOrUndefined);
    const result = await browser.checkTabbablePage(tag, options);
    return compareResult(result, expectedResult || DEFAULT_EXPECTED_RESULT);
}
