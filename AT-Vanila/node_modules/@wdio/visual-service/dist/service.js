import logger from '@wdio/logger';
import { expect } from '@wdio/globals';
import { dirname, normalize, resolve } from 'node:path';
import { BaseClass, checkElement, checkFullPageScreen, checkScreen, saveElement, saveFullPageScreen, saveScreen, saveTabbablePage, checkTabbablePage, FOLDERS, } from 'webdriver-image-comparison';
import { determineNativeContext, getFolders, getInstanceData } from './utils.js';
import { toMatchScreenSnapshot, toMatchFullPageSnapshot, toMatchElementSnapshot, toMatchTabbablePageSnapshot } from './matcher.js';
const log = logger('@wdio/visual-service');
const elementCommands = { saveElement, checkElement };
const pageCommands = {
    saveScreen,
    saveFullPageScreen,
    saveTabbablePage,
    checkScreen,
    checkFullPageScreen,
    checkTabbablePage,
};
export default class WdioImageComparisonService extends BaseClass {
    #config;
    #currentFile;
    #currentFilePath;
    _browser;
    _isNativeContext;
    constructor(options, _, config) {
        super(options);
        this.#config = config;
        this._isNativeContext = undefined;
    }
    /**
     * Set up the service if users want to use it in standalone mode
     */
    async remoteSetup(browser) {
        await this.before(browser.capabilities, [], browser);
    }
    async before(capabilities, _specs, browser) {
        this._browser = browser;
        this._isNativeContext = determineNativeContext(this._browser);
        if (!this._browser.isMultiremote) {
            log.info('Adding commands to global browser');
            await this.#addCommandsToBrowser(this._browser);
        }
        else {
            await this.#extendMultiremoteBrowser(capabilities);
        }
        /**
         * add custom matcher for visual comparison when expect has been added.
         * this is not the case in standalone mode
         */
        try {
            expect.extend({
                toMatchScreenSnapshot,
                toMatchFullPageSnapshot,
                toMatchElementSnapshot,
                toMatchTabbablePageSnapshot,
            });
        }
        catch (err) {
            log.warn('Expect package not found. This means that the custom matchers `toMatchScreenSnapshot|toMatchFullPageSnapshot|toMatchElementSnapshot|toMatchTabbablePageSnapshot` are not added and can not be used. Please make sure to add it to your `package.json` if you want to use the Visual custom matchers.');
        }
    }
    beforeTest(test) {
        this.#currentFile = (test.file || test.filename);
        this.#currentFilePath = resolve(dirname(this.#currentFile), FOLDERS.DEFAULT.BASE);
    }
    afterCommand(commandName, _args, result, error) {
        // This is for the cases where in the E2E tests we switch to a WEBVIEW or back to NATIVE_APP context
        if (commandName === 'getContext' && error === undefined && typeof result === 'string') {
            this._isNativeContext = result.includes('NATIVE');
        }
    }
    #getBaselineFolder() {
        const isDefaultBaselineFolder = normalize(FOLDERS.DEFAULT.BASE) === this.folders.baselineFolder;
        const baselineFolder = (isDefaultBaselineFolder && this.#currentFilePath ? this.#currentFilePath : this.folders.baselineFolder);
        /**
         * support `resolveSnapshotPath` WebdriverIO option
         * @ref https://webdriver.io/docs/configuration#resolvesnapshotpath
         *
         * We only use this option if the baselineFolder is the default one, otherwise the
         * service option for setting the baselineFolder should be used
         *
         * We also check `this.#config` because for standalone usage of the service, the config is not available
         */
        if (this.#config && typeof this.#config.resolveSnapshotPath === 'function' && this.#currentFile && isDefaultBaselineFolder) {
            return this.#config.resolveSnapshotPath(this.#currentFile, '.png');
        }
        return baselineFolder;
    }
    async #extendMultiremoteBrowser(capabilities) {
        const browser = this._browser;
        const browserNames = Object.keys(capabilities);
        log.info(`Adding commands to Multi Browser: ${browserNames.join(', ')}`);
        for (const browserName of browserNames) {
            const multiremoteBrowser = browser;
            const browserInstance = multiremoteBrowser.getInstance(browserName);
            await this.#addCommandsToBrowser(browserInstance);
        }
        /**
         * Add all the commands to the global browser object that will execute
         * on each browser in the Multi Remote
         */
        for (const command of [
            ...Object.keys(elementCommands),
            ...Object.keys(pageCommands),
        ]) {
            browser.addCommand(command, function (...args) {
                const returnData = {};
                for (const browserName of browserNames) {
                    const multiremoteBrowser = browser;
                    const browserInstance = multiremoteBrowser.getInstance(browserName);
                    /**
                     * casting command to `checkScreen` to simplify type handling here
                     */
                    returnData[browserName] = browserInstance[command].call(browserInstance, ...args);
                }
                return returnData;
            });
        }
    }
    async #addCommandsToBrowser(currentBrowser) {
        const instanceData = await getInstanceData(currentBrowser);
        const self = this;
        for (const [commandName, command] of Object.entries(elementCommands)) {
            log.info(`Adding element command "${commandName}" to browser object`);
            currentBrowser.addCommand(commandName, function (element, tag, elementOptions = {}) {
                return command({
                    executor: (script, ...varArgs) => {
                        return this.execute.bind(currentBrowser)(script, ...varArgs);
                    },
                    getElementRect: this.getElementRect.bind(currentBrowser),
                    screenShot: this.takeScreenshot.bind(currentBrowser),
                    takeElementScreenshot: this.takeElementScreenshot.bind(currentBrowser),
                }, instanceData, getFolders(elementOptions, self.folders, self.#getBaselineFolder()), element, tag, {
                    wic: self.defaultOptions,
                    method: elementOptions,
                }, self._isNativeContext);
            });
        }
        for (const [commandName, command] of Object.entries(pageCommands)) {
            log.info(`Adding element command "${commandName}" to browser object`);
            currentBrowser.addCommand(commandName, function (tag, pageOptions = {}) {
                return command({
                    executor: (script, ...varArgs) => {
                        return this.execute.bind(currentBrowser)(script, ...varArgs);
                    },
                    getElementRect: this.getElementRect.bind(currentBrowser),
                    screenShot: this.takeScreenshot.bind(currentBrowser),
                }, instanceData, getFolders(pageOptions, self.folders, self.#getBaselineFolder()), tag, {
                    wic: self.defaultOptions,
                    method: pageOptions,
                }, self._isNativeContext);
            });
        }
    }
}
