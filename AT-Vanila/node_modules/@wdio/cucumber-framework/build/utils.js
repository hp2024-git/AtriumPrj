import path from 'node:path';
import logger from '@wdio/logger';
import { isFunctionAsync } from '@wdio/utils';
import { CUCUMBER_HOOK_DEFINITION_TYPES } from './constants.js';
const log = logger('@wdio/cucumber-framework:utils');
/**
 * NOTE: this function is exported for testing only
 */
export function createStepArgument({ argument }) {
    if (!argument) {
        return undefined;
    }
    if (argument.dataTable) {
        return {
            rows: argument.dataTable.rows?.map((row) => ({
                cells: row.cells?.map((cell) => cell.value)
            }))
        };
    }
    if (argument.docString) {
        return argument.docString.content;
    }
    return undefined;
}
/**
 * format message
 * @param {object} message { type: string, payload: object }
 */
export function formatMessage({ payload = {} }) {
    const content = { ...payload };
    /**
     * need to convert Error to plain object, otherwise it is lost on process.send
     */
    if (payload.error && (payload.error.message || payload.error.stack)) {
        const { name, message, stack } = payload.error;
        content.error = { name, message, stack };
    }
    if (payload.title && payload.parent) {
        content.fullTitle = `${payload.parent}: ${payload.title}`;
    }
    return content;
}
var StepType;
(function (StepType) {
    StepType["hook"] = "hook";
    StepType["test"] = "test";
})(StepType || (StepType = {}));
/**
 * Get step type
 * @param {string} type `Step` or `Hook`
 */
export function getStepType(step) {
    return step.hookId ? StepType.hook : StepType.test;
}
export function getFeatureId(uri, feature) {
    return `${path.basename(uri)}:${feature.location?.line}:${feature.location?.column}`;
}
/**
 * Builds test title from step keyword and text
 * @param {string} keyword
 * @param {string} text
 * @param {string} type
 */
export function getTestStepTitle(keyword = '', text = '', type) {
    const title = (!text && type.toLowerCase() !== 'hook') ? 'Undefined Step' : text;
    return `${keyword.trim()} ${title.trim()}`.trim();
}
/**
 * build payload for test/hook event
 */
export function buildStepPayload(uri, feature, scenario, step, params) {
    return {
        ...params,
        uid: step.id,
        // @ts-ignore
        title: getTestStepTitle(step.keyword, step.text, params.type),
        parent: scenario.id,
        argument: createStepArgument(step),
        file: uri,
        tags: scenario.tags,
        featureName: feature.name,
        scenarioName: scenario.name,
    };
}
/**
 * The reporters need to have the rule.
 * They are NOT available on the scenario, they ARE on the feature.
 * This will add them to it
 */
export function getRule(feature, scenarioId) {
    const rules = feature.children?.filter((child) => Object.keys(child)[0] === 'rule');
    const rule = rules.find((rule) => {
        const scenarioRule = rule.rule?.children?.find((child) => child.scenario?.id === scenarioId);
        if (scenarioRule) {
            return rule;
        }
    });
    return rule?.rule?.name;
}
/**
 * The reporters need to have the keywords, like `Given|When|Then`. They are NOT available
 * on the scenario, they ARE on the feature.
 * This will aad them
 */
export function addKeywordToStep(steps, feature) {
    return steps.map(step => {
        // Steps without a astNodeIds are hooks
        if (step.astNodeIds && step.astNodeIds.length > 0 && feature.children) {
            // Points to the AST node locations of the pickle. The last one represents the unique id of the pickle.
            // A pickle constructed from Examples will have the first id originating from the Scenario AST node, and
            // the second from the TableRow AST node.
            // See https://github.com/cucumber/cucumber/blob/master/messages/messages.md
            const astNodeId = step.astNodeIds[0];
            const rules = feature.children.filter((child) => Object.keys(child)[0] === 'rule');
            let featureChildren = feature.children.filter((child) => Object.keys(child)[0] !== 'rule');
            const rulesChildrens = rules.map((child) => child.rule?.children).flat();
            featureChildren = featureChildren.concat(rulesChildrens);
            featureChildren.find((child) => 
            // @ts-ignore
            child[Object.keys(child)[0]].steps.find((featureScenarioStep) => {
                if (featureScenarioStep.id === astNodeId.toString()) {
                    step.keyword = featureScenarioStep.keyword;
                }
                return;
            }));
            return step;
        }
        return step;
    });
}
/**
 * Generates skip tags based on capabilities and provided tags.
 *
 * @param {Capabilities.RemoteCapability} capabilities - The capabilities for which skip tags will be generated.
 * @param {string[][]} tags - The original tags of scenarios.
 * @returns {string[]} - An array of generated skip tags in Cucumber tag expression format.
 */
export function generateSkipTagsFromCapabilities(capabilities, tags) {
    const generatedTags = [];
    const skipTag = /^@skip$|^@skip\((.*)\)$/;
    const match = (value, expr) => {
        if (Array.isArray(expr)) {
            return expr.indexOf(value) >= 0;
        }
        else if (expr instanceof RegExp) {
            return expr.test(value);
        }
        return ((expr && ('' + expr).toLowerCase()) ===
            (value && ('' + value).toLowerCase()));
    };
    const parse = (skipExpr) => skipExpr.split(';').reduce((acc, splitItem) => {
        const pos = splitItem.indexOf('=');
        if (pos > 0) {
            try {
                acc[splitItem.substring(0, pos)] = eval(splitItem.substring(pos + 1));
            }
            catch (err) {
                log.error(`Couldn't use tag "${splitItem}" for filtering because it is malformed`);
            }
        }
        return acc;
    }, {});
    tags.flat(1).forEach((tag) => {
        const matched = tag.match(skipTag);
        if (matched) {
            const isSkip = [parse(matched[1] ?? '')]
                .find((filter) => Object.keys(filter)
                .every((key) => match(capabilities[key], filter[key])));
            if (isSkip) {
                generatedTags.push(`(not ${tag.replace(/(\(|\))/g, '\\$1')})`);
            }
        }
    });
    return generatedTags;
}
/**
 * Retrives scenario description if available.
 */
export function getScenarioDescription(feature, scenarioId) {
    const children = feature.children?.find((child) => child?.scenario?.id === scenarioId);
    return children?.scenario?.description || '';
}
/**
 * wrap every user defined hook with function named `userHookFn`
 * to identify later on is function a step, user hook or wdio hook.
 * @param {object} options `Cucumber.supportCodeLibraryBuilder.options`
 */
export function setUserHookNames(options) {
    CUCUMBER_HOOK_DEFINITION_TYPES.forEach(hookName => {
        options[hookName].forEach((testRunHookDefinition) => {
            const hookFn = testRunHookDefinition.code;
            if (!hookFn.name.startsWith('wdioHook')) {
                const userHookAsyncFn = async function (...args) {
                    return hookFn.apply(this, args);
                };
                const userHookFn = function (...args) {
                    return hookFn.apply(this, args);
                };
                testRunHookDefinition.code = (isFunctionAsync(hookFn)) ? userHookAsyncFn : userHookFn;
            }
        });
    });
}
