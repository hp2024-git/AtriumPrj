import { calculateDprData, checkAndroidNativeWebScreenshot, checkIsIos, getScreenshotSize, isObject } from '../helpers/utils.js';
import { getElementPositionAndroid, getElementPositionDesktop, getElementPositionIos } from './elementPosition.js';
import { IOS_OFFSETS, ANDROID_OFFSETS } from '../helpers/constants.js';
import getIosStatusAddressToolBarOffsets from '../clientSideScripts/getIosStatusAddressToolBarOffsets.js';
import getAndroidStatusAddressToolBarOffsets from '../clientSideScripts/getAndroidStatusAddressToolBarOffsets.js';
/**
 * Determine the element rectangles on the page / screenshot
 */
export async function determineElementRectangles({ executor, base64Image, options, element, }) {
    // Determine screenshot data
    const { devicePixelRatio, innerHeight, isAndroid, isAndroidNativeWebScreenshot, isIOS, isLandscape, } = options;
    const { height } = getScreenshotSize(base64Image, devicePixelRatio);
    let elementPosition;
    // Determine the element position on the screenshot
    if (isIOS) {
        elementPosition = await getElementPositionIos(executor, element, { isLandscape });
    }
    else if (isAndroid) {
        elementPosition = await getElementPositionAndroid(executor, element, { isAndroidNativeWebScreenshot, isLandscape });
    }
    else {
        elementPosition = await getElementPositionDesktop(executor, element, { innerHeight, screenshotHeight: height });
    }
    // Validate if the element is visible
    if (elementPosition.height === 0 || elementPosition.width === 0) {
        let selectorMessage = ' ';
        if (element.selector) {
            selectorMessage = `, with selector "$(${element.selector})",`;
        }
        const message = `The element${selectorMessage}is not visible. The dimensions are ${elementPosition.width}x${elementPosition.height}`;
        throw new Error(message);
    }
    // Determine the rectangles based on the device pixel ratio
    return calculateDprData({
        height: elementPosition.height,
        width: elementPosition.width,
        x: elementPosition.x,
        y: elementPosition.y,
    }, devicePixelRatio);
}
/**
 * Determine the rectangles of the screen for the screenshot
 */
export function determineScreenRectangles(base64Image, options) {
    // Determine screenshot data
    const { devicePixelRatio, innerHeight, innerWidth, isIOS, isAndroidChromeDriverScreenshot, isAndroidNativeWebScreenshot, isLandscape, } = options;
    const { height, width } = getScreenshotSize(base64Image, devicePixelRatio);
    // Determine the width
    const screenshotWidth = isIOS || isAndroidChromeDriverScreenshot ? width : innerWidth;
    const screenshotHeight = isIOS || isAndroidNativeWebScreenshot ? height : innerHeight;
    const isRotated = isLandscape && height > width;
    // Determine the rectangles
    return calculateDprData({
        height: isRotated ? screenshotWidth : screenshotHeight,
        width: isRotated ? screenshotHeight : screenshotWidth,
        x: 0,
        y: 0,
    }, devicePixelRatio);
}
/**
 * Determine the rectangles for the mobile devices
 */
export async function determineStatusAddressToolBarRectangles(executor, options) {
    const { blockOutSideBar, blockOutStatusBar, blockOutToolBar, isAndroidNativeWebScreenshot, isHybridApp, isLandscape, isMobile, isViewPortScreenshot, platformName, } = options;
    const rectangles = [];
    if (isViewPortScreenshot &&
        isMobile &&
        (checkAndroidNativeWebScreenshot(platformName, isAndroidNativeWebScreenshot) || checkIsIos(platformName))) {
        const { sideBar, statusAddressBar, toolBar } = (await (checkIsIos(platformName)
            ? executor(getIosStatusAddressToolBarOffsets, IOS_OFFSETS, isLandscape)
            : executor(getAndroidStatusAddressToolBarOffsets, ANDROID_OFFSETS, {
                isHybridApp,
                isLandscape,
            })));
        if (blockOutStatusBar) {
            rectangles.push(statusAddressBar);
        }
        if (blockOutToolBar) {
            rectangles.push(toolBar);
        }
        if (blockOutSideBar) {
            rectangles.push(sideBar);
        }
    }
    return rectangles;
}
/**
 * Validate that the element is a WebdriverIO element
 */
export function isWdioElement(x) {
    if (!isObject(x)) {
        return false;
    }
    const region = x;
    const keys = ['selector', 'elementId'];
    return keys.every(key => typeof region[key] === 'string');
}
/**
 * Validate that the object is a valid ignore region
 */
function validateIgnoreRegion(x) {
    if (!isObject(x)) {
        return false;
    }
    const region = x;
    const keys = ['height', 'width', 'x', 'y'];
    return keys.every(key => typeof region[key] === 'number');
}
/**
 * Format the error message
 */
function formatErrorMessage(item, message) {
    const formattedItem = isObject(item) ? JSON.stringify(item) : item;
    return `${formattedItem} ${message}`;
}
/**
 * Split the ignores into elements and regions and throw an error if
 * an element is not a valid WebdriverIO element/region
 */
function splitIgnores(items) {
    const elements = [];
    const regions = [];
    const errorMessages = [];
    for (const item of items) {
        if (Array.isArray(item)) {
            for (const nestedItem of item) {
                if (!isWdioElement(nestedItem)) {
                    errorMessages.push(formatErrorMessage(nestedItem, 'is not a valid WebdriverIO element'));
                }
                else {
                    elements.push(nestedItem);
                }
            }
        }
        else if (isWdioElement(item)) {
            elements.push(item);
        }
        else if (validateIgnoreRegion(item)) {
            regions.push(item);
        }
        else {
            errorMessages.push(formatErrorMessage(item, 'is not a valid WebdriverIO element or region'));
        }
    }
    if (errorMessages.length > 0) {
        throw new Error('Invalid elements or regions: ' + errorMessages.join(', '));
    }
    return { elements, regions };
}
/**
 * Get the regions from the elements
 */
async function getRegionsFromElements(elements, getElementRect) {
    const regions = [];
    for (const element of elements) {
        const region = await getElementRect(element.elementId);
        regions.push(region);
    }
    return regions;
}
/**
 * Translate ignores to regions
 */
export async function determineIgnoreRegions(ignores, getElementRect) {
    const awaitedIgnores = await Promise.all(ignores);
    const { elements, regions } = splitIgnores(awaitedIgnores);
    const regionsFromElements = await getRegionsFromElements(elements, getElementRect);
    return [...regions, ...regionsFromElements]
        .map((region) => ({
        x: Math.round(region.x),
        y: Math.round(region.y),
        width: Math.round(region.width),
        height: Math.round(region.height),
    }));
}
/**
 * Determine the device block outs
 */
export async function determineDeviceBlockOuts({ isAndroid, screenCompareOptions, instanceData }) {
    const rectangles = [];
    const { blockOutStatusBar, blockOutToolBar } = screenCompareOptions;
    const { devicePlatformRect: { homeBar, statusBar } } = instanceData;
    if (blockOutStatusBar) {
        rectangles.push(statusBar);
    }
    if (isAndroid) {
        //
    }
    else if (blockOutToolBar) {
        rectangles.push(homeBar);
    }
    // @TODO: This is from the native-app-compare module, I can't really find the diffs between the two
    // if (options.blockOutStatusBar) {
    //     rectangles.push(deviceInfo.rectangles.statusBar)
    // }
    // if (driver.isAndroid && options.blockOutNavigationBar) {
    //     rectangles.push(deviceInfo.rectangles.androidNavigationBar)
    // }
    return rectangles;
}
