import { takeWebElementScreenshot } from '../methods/screenshots.js';
import { makeCroppedBase64Image } from '../methods/images.js';
import beforeScreenshot from '../helpers/beforeScreenshot.js';
import afterScreenshot from '../helpers/afterScreenshot.js';
import { DEFAULT_RESIZE_DIMENSIONS } from '../helpers/constants.js';
import scrollElementIntoView from '../clientSideScripts/scrollElementIntoView.js';
import { getScreenshotSize } from '../helpers/utils.js';
import scrollToPosition from '../clientSideScripts/scrollToPosition.js';
/**
 * Saves an image of an element
 */
export default async function saveWebElement(methods, instanceData, folders, element, tag, saveElementOptions, 
// eslint-disable-next-line @typescript-eslint/no-unused-vars
isNativeContext) {
    // 1a. Set some variables
    const { addressBarShadowPadding, autoElementScroll, formatImageName, savePerInstance, toolBarShadowPadding } = saveElementOptions.wic;
    const { executor, screenShot, takeElementScreenshot } = methods;
    // 1b. Set the method options to the right values
    const disableCSSAnimation = saveElementOptions.method.disableCSSAnimation !== undefined
        ? Boolean(saveElementOptions.method.disableCSSAnimation)
        : saveElementOptions.wic.disableCSSAnimation;
    const enableLayoutTesting = saveElementOptions.method.enableLayoutTesting !== undefined
        ? Boolean(saveElementOptions.method.enableLayoutTesting)
        : saveElementOptions.wic.enableLayoutTesting;
    const hideScrollBars = saveElementOptions.method.hideScrollBars !== undefined
        ? Boolean(saveElementOptions.method.hideScrollBars)
        : saveElementOptions.wic.hideScrollBars;
    const resizeDimensions = saveElementOptions.method.resizeDimensions || DEFAULT_RESIZE_DIMENSIONS;
    const hideElements = saveElementOptions.method.hideElements || [];
    const removeElements = saveElementOptions.method.removeElements || [];
    const waitForFontsLoaded = saveElementOptions.method.waitForFontsLoaded !== undefined
        ? Boolean(saveElementOptions.method.waitForFontsLoaded)
        : saveElementOptions.wic.waitForFontsLoaded;
    // 2.  Prepare the beforeScreenshot
    const beforeOptions = {
        instanceData,
        addressBarShadowPadding,
        disableCSSAnimation,
        enableLayoutTesting,
        hideElements,
        noScrollBars: hideScrollBars,
        removeElements,
        toolBarShadowPadding,
        waitForFontsLoaded,
    };
    const enrichedInstanceData = await beforeScreenshot(executor, beforeOptions, true);
    const { browserName, browserVersion, deviceName, dimensions: { window: { devicePixelRatio, innerHeight, isLandscape, outerHeight, outerWidth, screenHeight, screenWidth }, }, isAndroid, isAndroidNativeWebScreenshot, isIOS, isMobile, isTestInBrowser, logName, name, platformName, platformVersion, } = enrichedInstanceData;
    // Scroll the element into top of the viewport and return the current scroll position
    let currentPosition;
    if (autoElementScroll) {
        currentPosition = await executor(scrollElementIntoView, element, addressBarShadowPadding);
    }
    // 3.  Take the screenshot and determine the rectangles
    const { base64Image, rectangles, isWebDriverElementScreenshot } = await takeWebElementScreenshot({
        devicePixelRatio,
        element,
        executor,
        innerHeight,
        isAndroidNativeWebScreenshot,
        isAndroid,
        isIOS,
        isLandscape,
        screenShot,
        takeElementScreenshot,
    });
    // When the screenshot has been taken and the element position has been determined,
    // we can scroll back to the original position
    // We don't need to wait for the scroll here because we don't take a screenshot after this
    if (autoElementScroll && currentPosition) {
        await executor(scrollToPosition, currentPosition);
    }
    // When the element has no height or width, we default to the viewport screen size
    if (rectangles.width === 0 || rectangles.height === 0) {
        const { height, width } = getScreenshotSize(base64Image);
        rectangles.width = width;
        rectangles.height = height;
        rectangles.x = 0;
        rectangles.y = 0;
        console.error(`\x1b[31m\nThe element has no width or height. We defaulted to the viewport screen size of width: ${width} and height: ${height}.\x1b[0m\n`);
    }
    // 5.  Make a cropped base64 image with resizeDimensions
    // @TODO: we have isLandscape here
    const croppedBase64Image = await makeCroppedBase64Image({
        addIOSBezelCorners: false,
        base64Image,
        deviceName,
        devicePixelRatio: devicePixelRatio || NaN,
        isWebDriverElementScreenshot,
        isIOS,
        isLandscape,
        rectangles,
        resizeDimensions,
    });
    // 6.  The after the screenshot methods
    const afterOptions = {
        actualFolder: folders.actualFolder,
        base64Image: croppedBase64Image,
        disableCSSAnimation,
        enableLayoutTesting,
        filePath: {
            browserName,
            deviceName,
            isMobile,
            savePerInstance: savePerInstance,
        },
        fileName: {
            browserName,
            browserVersion,
            deviceName,
            devicePixelRatio: devicePixelRatio || NaN,
            formatImageName,
            isMobile,
            isTestInBrowser,
            logName,
            name,
            outerHeight: outerHeight || NaN,
            outerWidth: outerWidth || NaN,
            platformName,
            platformVersion,
            screenHeight: screenHeight || NaN,
            screenWidth: screenWidth || NaN,
            tag,
        },
        hideElements,
        hideScrollBars,
        isLandscape,
        isNativeContext: false,
        platformName: instanceData.platformName,
        removeElements,
    };
    // 7.  Return the data
    return afterScreenshot(executor, afterOptions);
}
